<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html xmlns='http://www.w3.org/1999/xhtml'>
  <head>
    <meta http-equiv='content-type' content='text/html; charset=utf-8'/> 
    <title>Borran/Fatemi/Horstmann Scala Unit 12</title> 
    <link href='http://www.w3.org/Talks/Tools/Slidy2/styles/slidy.css' media='screen, projection, print' rel='stylesheet' type='text/css'/> 
    <link href='../MySlidy/style.css' media='screen, projection, print' rel='stylesheet' type='text/css'/> 
    <script type='text/javascript' charset='utf-8' src='http://www.w3.org/Talks/Tools/Slidy2/scripts/slidy.js.gz'></script>
    <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML"></script>
  </head> 
  <body>

    <h1>Programmation appliquée en Scala</h1> 
    <p class='fullimage'><img src='../images/cheseaux.jpg'/></p> 
    <div class='license'>
      <p>Copyright © Cay S. Horstmann 2015 <a rel='license' href='http://creativecommons.org/licenses/by/4.0/'><img alt='Creative Commons License' style='border-width:0' src='https://i.creativecommons.org/l/by/4.0/88x31.png'/></a><br/>This work is licensed under a <a rel='license' href='http://creativecommons.org/licenses/by/4.0/'>Creative Commons Attribution 4.0 International License</a> </p> 
    </div> 

    <h1>Collections: recall List</h1> 
	<p>A list having <script type="math/tex" id="MathJax-Element-1"> x_1, ..., x_n</script> <br>
	as elements is written <code>List(</code><script type="math/tex" id="MathJax-Element-2"> x_1, …, x_n</script><code>)</code></p>

	<p>Example</p>

	<pre><code>val fruit  = List("apples", "oranges", "pears")
val nums   = List(1, 2, 3, 4)
val diag3  = List(List(1, 0, 0), List(0, 1, 0), List(0, 0, 1))
val empty  = List()
	</code></pre>

<p>There are two important differences between lists and arrays.</p>

<ul>
<li>Lists are immutable — the elements of a list cannot be changed.</li>
<li>Lists are recursive, while arrays are flat.</li>

</ul>

    <h1>add more on Lists + exercice</h1> 
    

    <h1 id="other-sequences">Other Sequences</h1>

	<p>We have seen that lists are <em>linear</em>: Access to the first element is <br>
	much faster than access to the middle or end of a list.</p>

	<p>The Scala library also defines an alternative sequence implementation, <code>Vector</code>.</p>

	<p>This one has more evenly balanced access patterns than <code>List</code>.</p>



	<h1 id="operations-on-vectors">Operations on Vectors</h1>

	<p>Vectors are created analogously to lists:</p>

	<pre><code>  val nums = Vector(1, 2, 3, -88)
  val people = Vector("Bob", "James", "Peter")
	</code></pre>

	<p>They support the same operations as lists, with the exception of <code>::</code></p>

	<p>Instead of <code>x :: xs</code>, there is</p>



	<p>
	   <code>&nbsp;&nbsp;&nbsp;x +: xs</code>&nbsp;&nbsp;&nbsp;Create a new vector with leading element <code>x</code>, followed by all elements of <code>xs</code>.</br></br>
	   <code>&nbsp;&nbsp;&nbsp;xs :+ x</code>&nbsp;&nbsp;&nbsp;Create a new vector with trailing element <code>x</code>, preceded by all elements of <code>xs</code>.</br>
    <br>
	(Note that the <code>:</code> always points to the sequence.)</p>
	

	<h1 id="collection-hierarchy">Collection Hierarchy</h1>

	<p>A common base class of <code>List</code> and <code>Vector</code> is <code>Seq</code>, the class of all <em>sequences</em>. </p>

	<p><code>Seq</code> itself is a subclass of <code>Iterable</code>. </p>

     <img src="collectionsImmutable.png" alt="Immutable Collections" style="width:70%;height:70%">

	<h1 id="arrays-and-strings">Arrays and Strings</h1>

	<p>Arrays and Strings support the same operations as <code>Seq</code> and can <br>
	implicitly be converted to sequences where needed.</p>

	<p>(They cannot be subclasses of <code>Seq</code> because they come from Java)</p>

	<pre><code>  val xs: Array[Int] = Array(1, 2, 3)
  xs map (x =&gt; 2 * x)

  val ys: String = "Hello world!"
  ys filter (_.isUpper)
	</code></pre>

	<h1 id="ranges">Ranges</h1>

	<p>Another simple kind of sequence is the <em>range</em>.</p>

	<p>It represents a sequence of evenly spaced integers.</p>

	<p>Three operators:</p>

	<p><code>to</code> (inclusive), <code>until</code> (exclusive), <code>by</code> (to	determine step value):</p>

	<pre><code>  val r: Range = 1 until 5
  val s: Range = 1 to 5
  1 to 10 by 3
  6 to 1 by -2
	</code></pre>

	<p>Ranges are represented as single objects with three fields:  <br>
	lower bound, upper bound, step value.</p>



	<h1 id="some-more-sequence-operations">Some more Sequence Operations:</h1>

	<p><script type="math/tex; mode=display" id="MathJax-Element-2">\begin{tabular}{lp{8.7cm}}
	   \verb`  xs exists p    `  & \verb`true` if there is an element \verb`x` of \verb`xs` such that \verb`p(x)` holds, \verb`false` otherwise.
	\\ \verb`  xs forall p    `  & \verb`true` if \verb`p(x)` holds for all elements \verb`x` of \verb`xs`, \verb`false` otherwise.
	\\ \verb`  xs zip ys      `  & A sequence of pairs drawn from corresponding elements of sequences \verb`xs` and \verb`ys`.
	\\ \verb`  xs.unzip       `  & Splits a sequence of pairs \verb`xs` into two sequences consisting of the first, respectively second halves of all pairs.
	\\ \verb`  xs.flatMap f   `  & Applies collection-valued function \verb`f` to all elements of \verb`xs` and concatenates the results
	\\ \verb`  xs.sum         `  & The sum of all elements of this numeric collection.
	\\ \verb`  xs.product     `  & The product of all elements of this numeric collection
	\\ \verb`  xs.max         `  & The maximum of all elements of this collection (an \verb`Ordering` must exist)
	\\ \verb`  xs.min         `  & The minimum of all elements of this collection
	\end{tabular}</script></p>



	<h1 id="example-combinations">Example: Combinations</h1>

	<p>To list all combinations of numbers <code>x</code> and <code>y</code> where <code>x</code> is drawn from <code>1..M</code> and <code>y</code> is drawn from <code>1..N</code>:</p>

	<pre><code>  (1 to M) flatMap (x =&gt; 
	</code></pre>



	<h1 id="example-combinations-1">Example: Combinations</h1>

	<p>To list all combinations of numbers <code>x</code> and <code>y</code> where <code>x</code> is drawn from <code>1..M</code> and <code>y</code> is drawn from <code>1..N</code>:</p>

	<pre><code>  (1 to M) flatMap (x =&gt; (1 to N) map (y =&gt; (x, y)))
	</code></pre>



	<h1 id="example-scalar-product">Example: Scalar Product</h1>

	<p>To compute the scalar product of two vectors:</p>

	<pre><code>  def scalarProduct(xs: Vector[Double], ys: Vector[Double]): Double =
		(xs zip ys).map(xy =&gt; xy._1 * xy._2).sum
	</code></pre>

	<p>-&gt; <br>
	An alternative way to write this is with a \red{pattern matching function value}.</p>

	<pre><code>  def scalarProduct(xs: Vector[Double], ys: Vector[Double]): Double =
		(xs zip ys).map{ case (x, y) =&gt; x * y }.sum
	</code></pre>

	<p>Generally, the function value</p>

	<pre><code>  { case p1 =&gt; e1 ... case pn =&gt; en }
	</code></pre>

	<p>is equivalent to </p>

	<pre><code>  x =&gt; x match { case p1 =&gt; e1 ... case pn =&gt; en }
	</code></pre>



	<h1 id="exercise">Exercise:</h1>

	<p>A number <code>n</code> is \red{prime} if the only divisors of <code>n</code> are <code>1</code> and <code>n</code> itself.</p>

	<p>What is a high-level way to write a test for primality of numbers? For <br>
	once, value conciseness over efficiency.</p>

	<pre><code>  def isPrime(n: Int): Boolean = ???
	</code></pre>



	<h1 id="exercise-1">Exercise:</h1>

	<p>A number <code>n</code> is \red{prime} if the only divisors of <code>n</code> are <code>1</code> and <code>n</code> itself.</p>

	<p>What is a high-level way to write a test for primality of numbers? For <br>
	once, value conciseness over efficiency.</p>

	<pre><code>  def isPrime(n: Int): Boolean = 
	</code></pre>
   

      <h1>Lab</h1> 
      <p class='sideimage'><img alt='Scary looking lab' src='../images/lab.jpg'/></p> 
      <ul>
        <li>You work with a buddy </li> 
        <li>One of you (the coder) writes the code, the other (the scribe) types up answers</li> 
        <li>When you get stuck, ask your buddy first!</li> 
        <li>Switch coder/scribe roles each lab</li> 
        <li>The coder submits the worksheet. Include the scribe's name in the worksheet!</li> 
        <li>The scribe submits answers. Include the coder's name in the report!</li> 
      </ul> 

      
      <h1>Part 1: Expressions</h1> 
      
      <h1>Homework</h1> 
      <p>Do this as <em>individual work</em>, not with your partner</p> 
      <p>When all done, email the signed zip files to Fatemeh.Borran@heig-vd.ch</p> 
      
    </body>
  </html>
